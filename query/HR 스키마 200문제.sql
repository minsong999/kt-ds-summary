-- 사원 정보 테이블에서 이름과 성, 연봉, 이메일을 조회한다.
SELECT FIRST_NAME, LAST_NAME, SALARY, EMAIL FROM EMPLOYEES e
;
-- 지역 정보 테이블에서 도시명이 "Seattle" 인 지역의 주소와 우편번호를 조회한다.
SELECT STREET_ADDRESS 
	, POSTAL_CODE  
FROM LOCATIONS l 
WHERE CITY = 'Seattle'
;
-- 모든 사원들의 연봉 총합, 최대 연봉, 최소 연봉, 평균 연봉, 사원의 수를 조회.
SELECT SUM(SALARY)
	, MAX(SALARY)
	, MIN(SALARY)
	, AVG(SALARY)
	, COUNT(EMPLOYEE_ID) --COUNT 함수의 파라미터는 PK를 쓰는 것이 원칙
	, MAX(HIRE_DATE) -- 가장 최신 입사일
	, MIN(HIRE_DATE) -- 가장 과거 입사일
FROM EMPLOYEES e 
;
-- 2007년에 입사한 사원의 수와 평균 연봉을 조회.
-- 문자 -> 날짜 변경
SELECT TO_DATE('2008-01-01', 'YYYY-MM-DD') 
FROM DUAL -- DUAL (DUMMY 테이블 : 날짜, 시퀀셜할 번호등을 조회)  
;
SELECT COUNT(EMPLOYEE_ID)
	, AVG(SALARY)
FROM EMPLOYEES e 
WHERE HIRE_DATE  >= TO_DATE('2007-01-01', 'YYYY-MM-DD')
	AND HIRE_DATE  <= TO_DATE('2007-12-31', 'YYYY-MM-DD')
;
-- GROUP BY
-- 부셔별 근무중인 부서번호, 연봉의 합계, 최대 연봉, 가장 늦게 입사한 날짜, 가장 일찍 입사한 날짜, 사원의 수 조회. 
SELECT DEPARTMENT_ID  --  ORA-00937: 단일 그룹의 그룹 함수가 아닙니다
	, SUM(SALARY)
	, MAX(SALARY)
	, MAX(HIRE_DATE)
	, MIN(SALARY)
	, MIN(HIRE_DATE)
	, COUNT(EMPLOYEE_ID)
FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID 
;
-- 사원 정보에서 "직무 아이디" 별 "사원의 수"와 "직무 아이디"를 조회한다.
SELECT
	COUNT(EMPLOYEE_ID)
	, JOB_ID
FROM EMPLOYEES
GROUP BY JOB_ID
;
-- 사원 정보에서 "성"이 같은 사원들의 "수"와 성을 조회한다.
SELECT 
	COUNT(EMPLOYEE_ID)
	,LAST_NAME
FROM EMPLOYEES
GROUP BY LAST_NAME
;
-- 2004년에 입사한 사원들 중
-- 부서 번호별 사원들의 수와 평균 연봉, 연봉의 총합, 부서번호를 조회한다.
SELECT 
	COUNT(EMPLOYEE_ID)
	, AVG(SALARY)
	, SUM(SALARY)
	, DEPARTMENT_ID
FROM EMPLOYEES e 
WHERE HIRE_DATE > TO_DATE('2004-01-01')
	AND HIRE_DATE < TO_DATE('2004-12-31')
GROUP BY DEPARTMENT_ID 
;
-- 사원 정보에서 동일한 "성"을 두 명 이상이 있는 사원들만 조회한다.
-- "성"별 사원의 수, "성"
SELECT COUNT(EMPLOYEE_ID)
	, LAST_NAME
	FROM EMPLOYEES e
	GROUP BY LAST_NAME 
	HAVING COUNT(LAST_NAME) > 1
;
-- 사원 정보에서 직무 아이디별 사원의 수와 직무 아이디를 조회하는데
-- 사원의 수가 3명 이상인 정보만 조회한다.
SELECT COUNT(EMPLOYEE_ID)
	,JOB_ID
	FROM EMPLOYEES e 
	GROUP BY JOB_ID 
	HAVING COUNT(EMPLOYEE_ID) >= 3 
;
-- SUB QUERY
-- 1. 부서명 IT 부서에서 근무중인 사원들의 정보를 조회
SELECT DEPARTMENT_ID  
			FROM DEPARTMENTS d  
			WHERE DEPARTMENT_NAME = 'IT'	
;			
-- 2. 60번 부서에서 일을 하는 사원들의 정보를 조회한다.			
	SELECT * FROM EMPLOYEES e 
	WHERE DEPARTMENT_ID = 60
;
-- SUB QUERY 이용
-- SUB QUERY 먼저 작성(우리가 알기 위해 필요한 코드를 먼저 작성)
SELECT * FROM EMPLOYEES e 
	WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID  
							FROM DEPARTMENTS d  
							WHERE DEPARTMENT_NAME = 'IT')	
;
-- 지역 번호가 1700인 부서에서 근무주인 사원들의 모든 정보를 조회. (지역번호가 1700인 부서의 번호를 모르는 상황)
SELECT * 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
						FROM DEPARTMENTS d
						WHERE LOCATION_ID = 1700)							

-- 145번 사원이 부서장인 부서에서 근무중인 사원들의 모든 정보를 조회하는데
-- 결과에서 145번 사원은 제외시킨다.
;
SELECT * FROM EMPLOYEES e 
WHERE e.DEPARTMENT_ID =(SELECT DEPARTMENT_ID 
						FROM DEPARTMENTS
						WHERE MANAGER_ID ='145'
						)
	AND EMPLOYEE_ID != 145
;					
-- 직무 명이 "Marketing Manager" 인 사원의 모든 정보를 조회한다.
-- 직무명 - 직무정보(JOBS)
-- 사원의 모든 정보 : 사원 정보(Employee)
SELECT * 
FROM EMPLOYEES 
WHERE JOB_ID =(SELECT JOB_ID 
				FROM JOBS 
				WHERE JOB_TITLE ='Marketing Manager')
;

-- 도시명이 "Seattle" 인 지역에 존재하는 부서의 모든 정보를 조회한다.
SELECT * FROM DEPARTMENTS d 
WHERE d.LOCATION_ID =(SELECT LOCATION_ID 
						FROM LOCATIONS 
					WHERE CITY ='Seattle')
;

-- 대륙명이 "Americas"인 국가 정보를 모두 조회한다.
SELECT * 
FROM COUNTRIES
WHERE REGION_ID =(SELECT REGION_ID 
					FROM REGIONS 
					WHERE REGION_NAME ='Americas')
;					
-- 도시명 "Seattle" 인 지역에서 근무중인 모든 사원들의 정보를 조회한다.
SELECT * 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
						FROM DEPARTMENTS 
						WHERE LOCATION_ID=(SELECT LOCATION_ID  
											FROM LOCATIONS 
											WHERE CITY ='Seattle'))
;

-- 대륙명이 'Europe'인 국가에서 근무하는 모든 사원들의 정보를 조회
SELECT * 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
						FROM DEPARTMENTS 
						WHERE LOCATION_ID IN (SELECT LOCATION_ID 
												FROM LOCATIONS 
												WHERE COUNTRY_ID IN (SELECT COUNTRY_ID 
																		FROM COUNTRIES 
																		WHERE REGION_ID = (SELECT REGION_ID 
																							FROM REGIONS 
																							WHERE REGION_NAME ='Europe'))))
;

-- SUBQUERY - 여러 테이블을 연결해서 한 테이블의 정보 조회
-- INNER JOIN - 여러 테이블을 연결해서 여러 테이블의 정보 동시 조회

SELECT E.FIRST_NAME , L.CITY 
FROM EMPLOYEES e 
INNER JOIN DEPARTMENTS d ON E.DEPARTMENT_ID =D.DEPARTMENT_ID 
INNER JOIN LOCATIONS l ON D.LOCATION_ID =L.LOCATION_ID 
INNER JOIN COUNTRIES c ON L.COUNTRY_ID = C.COUNTRY_ID 
INNER JOIN REGIONS r ON C.REGION_ID = R.REGION_ID 
WHERE R.REGION_NAME ='Europe'
;
-- INNER JOIN
-- 문법
--SELECT A.*
--	,B.*
--	FROM TABLE A
--	INNER JOIN TABLE B
--	ON A.PK = B.PK

-- EMPLOYEES 와 DEPARTMENTS 의 모든 정보를 조회
SELECT *
	FROM EMPLOYEES E
	INNER JOIN DEPARTMENTS D 
	ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
;

-- 사원들이 근무하는 부서의 이름의 도시명, 사원들의 이름을 조회한다.
SELECT D.DEPARTMENT_NAME ,L.CITY , E.FIRST_NAME 
FROM EMPLOYEES e 
INNER JOIN DEPARTMENTS d ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
INNER JOIN LOCATIONS l ON D.LOCATION_ID = L.LOCATION_ID 
;

-- 103번 사원 이름, 연봉, 사원번호, 부서의 이름, 도시명을 조회한다.
SELECT E.FIRST_NAME , E.SALARY , E.EMPLOYEE_ID , D.DEPARTMENT_NAME , L.CITY  
FROM EMPLOYEES e
INNER JOIN DEPARTMENTS d ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
INNER JOIN LOCATIONS l ON D.LOCATION_ID = L.LOCATION_ID 
WHERE E.EMPLOYEE_ID  = '103'
;

SELECT E.FIRST_NAME , E.SALARY , E.EMPLOYEE_ID , D.DEPARTMENT_NAME , L.CITY   FROM
(SELECT E.FIRST_NAME , E.SALARY , E.EMPLOYEE_ID, E.DEPARTMENT_ID
FROM EMPLOYEES e
WHERE E.EMPLOYEE_ID  = '103') E
INNER JOIN DEPARTMENTS d ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
INNER JOIN LOCATIONS l ON D.LOCATION_ID = L.LOCATION_ID 
;

-- JOIN을 표현하는 여러가지단어
-- JOIN
-- EQUIP JOIN
-- NATURAL JOIN
-- INNER JOIN

-- 사원번호가 150번 이하인 사원들의 이름과 성, 연봉, 직무아이디, 직무명을 조회

SELECT E.FIRST_NAME , E.LAST_NAME , E.SALARY , D.DEPARTMENT_ID , D.DEPARTMENT_NAME 
FROM EMPLOYEES e 
INNER JOIN DEPARTMENTS d ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
WHERE E.EMPLOYEE_ID < 150
;

-- 부서번호, 부서명, 부서장의 사원번호, 부서장의 이름, 부서장의 성, 부서장의 직무명을 조회
SELECT D.DEPARTMENT_ID 
, D.DEPARTMENT_NAME 
, D.MANAGER_ID 
, E.FIRST_NAME  
, E.LAST_NAME 
, J.JOB_ID 
FROM DEPARTMENTS d 
INNER JOIN EMPLOYEES e 
ON D.MANAGER_ID = E.EMPLOYEE_ID 
INNER JOIN JOBS j 
ON E.JOB_ID = J.JOB_ID 
;
-- 대륙명, 국가명, 지역의 도시명을 조회한다.
SELECT R.REGION_NAME 
, C.COUNTRY_NAME 
, L.CITY 
FROM REGIONS r 
INNER JOIN COUNTRIES c ON R.REGION_ID = C.REGION_ID 
INNER JOIN LOCATIONS l ON C.COUNTRY_ID = L.COUNTRY_ID 
;
-- 사원의 모든 정보와 사원이 근무중인 부서의 이름, 부서가 있는 지역의 도시명, 도시가 있는 국가명, 국가가 있는 대륙명, 직무명을 조회한다.
SELECT E.* 
, D.DEPARTMENT_NAME 
, L.CITY
, C.COUNTRY_NAME 
, R.REGION_NAME 
, J.JOB_TITLE 
FROM EMPLOYEES e 
INNER JOIN DEPARTMENTS d ON E.DEPARTMENT_ID =D.DEPARTMENT_ID 
INNER JOIN LOCATIONS l ON D.LOCATION_ID =L.LOCATION_ID 
INNER JOIN COUNTRIES c ON L.COUNTRY_ID = C.COUNTRY_ID  
INNER JOIN REGIONS r ON C.REGION_ID = R.REGION_ID 
INNER JOIN JOBS j ON E.JOB_ID = J.JOB_ID 
;
SELECT * FROM EMPLOYEES e 
WHERE DEPARTMENT_ID = NULL 
;

-- 과거에 직무가 변경된 적이 있는 사원들의 모든 정보를 조회한다.

SELECT * FROM JOB_HISTORY jh 
ORDER BY EMPLOYEE_ID DESC, START_DATE ASC
;

SELECT DISTINCT(e.EMPLOYEE_ID) ,e.*
FROM EMPLOYEES e 
INNER JOIN JOB_HISTORY jh ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID 
;

SELECT E.* 
FROM EMPLOYEES e
WHERE EMPLOYEE_ID IN (SELECT EMPLOYEE_ID FROM JOB_HISTORY jh)
;

-- 직무가 변경된 적이 있는 사원의 과거 직무명과 현재 직무명을 조회.
SELECT e.EMPLOYEE_ID 
		, pj.JOB_TITLE AS PastJob
		, j.JOB_TITLE
FROM EMPLOYEES e
INNER JOIN JOBS j 
ON E.JOB_ID = J.JOB_ID
INNER JOIN JOB_HISTORY jh 
	ON	E.EMPLOYEE_ID = JH.EMPLOYEE_ID
INNER JOIN JOBS pj 
	ON pj.JOB_ID = jh.JOB_ID
;

-- 메뉴, 계단식 정보를 조회할 때 많이 사용한다.
-- 183번 사원 이름과 상사 정보를 조회한다.
-- 사원 - 부서 -상사
SELECT *
FROM EMPLOYEES E -- 사원정보
INNER JOIN EMPLOYEES M -- 상사정보
ON E.MANAGER_ID = M.EMPLOYEE_ID  
WHERE E.EMPLOYEE_ID = 183
;
-- 검증하기
-- 1. 로우수 확인
-- 2. 조건 확인
-- 3. 검색한 데이터 확인

-- LEFT OUTER JOIN 
-- 모든 사원들의 이름, 성, 부서명을 조회한다. 만약 부서에 속해있지 않는 사원이라면 NULL로 표기한다.
-- 107건
SELECT * FROM EMPLOYEES e 
LEFT JOIN DEPARTMENTS d 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
;
-- 122건
SELECT * FROM DEPARTMENTS D 
LEFT JOIN EMPLOYEES e 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
;
-- 근무하는 사원이 없는는 부서의 정보를 left OUTER 으로 조회한다.
SELECT * FROM DEPARTMENTS D 
LEFT JOIN EMPLOYEES e 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID 
WHERE E.EMPLOYEE_ID IS NULL 
;

-- 부서가 존재하지 않는 도시의 이름을 LEFT OUTER JOIN으로 조회한다.
SELECT L.CITY  FROM LOCATIONS l 
LEFT JOIN DEPARTMENTS d 
ON D.LOCATION_ID =L.LOCATION_ID 
WHERE D.DEPARTMENT_ID IS NULL
;

-- 1. 대륙에 존재하는 국가를 모두 조회한다. 국가가 없을 경우 NULL로 표기한다.
SELECT R.REGION_NAME , COUNTRY_NAME 
FROM REGIONS r 
LEFT JOIN COUNTRIES c 
ON R.REGION_ID = C.REGION_ID 
;
-- 2. 대륙명별 국가의 수를 모두 조회한다. 국가가 없을 경우 0으로 표기한다.
-- 3. 직무명별 사원의 수를 모두 조회한다. 사원의 수가 없을 경우 0으로 표기한다.
-- 4. 직무명별 사원의 수를 모두 조회한다. 단, 사원의 수가 2명 이상인 경우만 조회한다.
-- 5. 근무하는 사원이 단 한명도 없는 도시를 조회한다. (LEFT OUTER JOIN)



SELECT REGION_NAME ,COUNT(COUNTRY_ID) 
FROM REGIONS r 
LEFT JOIN COUNTRIES c 
ON R.REGION_ID = C.REGION_ID 
GROUP BY REGION_NAME 
;

SELECT JOB_TITLE ,COUNT(*) FROM JOBS j 
LEFT JOIN EMPLOYEES e ON J.JOB_ID =E.JOB_ID 
GROUP BY J.JOB_TITLE
;

SELECT JOB_TITLE ,COUNT(*) FROM JOBS j 
INNER JOIN EMPLOYEES e ON J.JOB_ID =E.JOB_ID 
GROUP BY J.JOB_TITLE
HAVING COUNT(J.JOB_TITLE)>=2 
;

SELECT L.CITY 
FROM LOCATIONS l 
LEFT JOIN DEPARTMENTS d ON L.LOCATION_ID = D.LOCATION_ID 
LEFT JOIN EMPLOYEES e ON D.DEPARTMENT_ID = E.EMPLOYEE_ID 
WHERE D.DEPARTMENT_ID IS NULL
;

--인라인 뷰 문법 () 내부에 새로운 SELECT 쿼리를 작성한다.
-- SELECT COLUMN...
-- FROM () A
-- INNER JOIN () B
-- WHERE ...

-- 사원의 정보를 INLINE VIEW를 이용해 조회한다.
-- INLINE VIEW로이용할 SELECT 문장을 먼저 작성.
SELECT EMPLOYEE_ID ,SALARY
FROM (SELECT EMPLOYEE_ID 
			,FIRST_NAME 
			,LAST_NAME 
			,SALARY
		FROM EMPLOYEES) TEMP_E
;

-- EMPLOYEES 테이블에서 연봉을 가장 많이 받는 사원 3명만 조회한다.
SELECT SALARY AS S,E.* 
FROM EMPLOYEES e 
WHERE ROWNUM<=3
ORDER BY SALARY ASC;
--ORDER BY 가 마지막에 실행되기 때문에 이 방식으로는 풀 수 없다.
--INLINE VIEW 이용해서 풀기
-- 1. EMPLOYEES 테이블에서 연봉을 기준으로 내림차순 정렬
SELECT SALARY ,EMPLOYEE_ID FROM
(SELECT * 
FROM EMPLOYEES e 
ORDER BY SALARY DESC ) ORDERED_EMPLOYEES
WHERE ROWNUM<=3
;
SELECT SALARY ,EMPLOYEE_ID FROM
(SELECT * 
FROM EMPLOYEES e 
ORDER BY SALARY ASC ) ORDERED_EMPLOYEES
WHERE ROWNUM<=3
;

-- 가장 많은 사원이 근무중인 부서의 모든 정보를 조회한다.
-- 부서별 사원의 수(부서에 사원이 존재하지 않는다면 0으로 조회한다.)
SELECT * FROM DEPARTMENTS d WHERE DEPARTMENT_ID =
(SELECT DEPARTMENT_ID 
FROM (-- 사원의 수로 내림차순 정렬
		SELECT  D.DEPARTMENT_ID
			, COUNT(E.EMPLOYEE_ID) AS E_COUNT
		FROM DEPARTMENTS d 
		LEFT JOIN EMPLOYEES e ON D.DEPARTMENT_ID = E.DEPARTMENT_ID 
		GROUP BY D.DEPARTMENT_ID 
		ORDER BY E_COUNT DESC
	) ORDERED_DEPT_EMP_COUNT
-- 정렬된 데이터에서 1개만 조회
WHERE ROWNUM = 1
)
;

SELECT D.*
FROM (-- 사원의 수로 내림차순 정렬
		SELECT  D.DEPARTMENT_ID
			, COUNT(E.EMPLOYEE_ID) AS E_COUNT
		FROM DEPARTMENTS d 
		LEFT JOIN EMPLOYEES e ON D.DEPARTMENT_ID = E.DEPARTMENT_ID 
		GROUP BY D.DEPARTMENT_ID 
		ORDER BY E_COUNT DESC
	) ORDERED_DEPT_EMP_COUNT
 	INNER JOIN DEPARTMENTS D
	ON D.DEPARTMENT_ID = ORDERED_DEPT_EMP_COUNT.DEPARTMENT_ID
-- 정렬된 데이터에서 1개만 조회
WHERE ROWNUM = 1
;

-- 연봉의 총 합이 가장 높은 부서의 모든 정보를 조회한다.
-- 부서별 연봉 총합.
SELECT D.* FROM (
	SELECT D.DEPARTMENT_ID 
		, SUM(NVL(SALARY,0)) AS SUM_SALARY 
		FROM DEPARTMENTS d 
		LEFT JOIN EMPLOYEES e ON D.DEPARTMENT_ID = E.DEPARTMENT_ID 
		GROUP BY D.DEPARTMENT_ID 
		-- 연봉 총합으로 내림차순 정렬.
		ORDER BY SUM_SALARY DESC 
	) ORDERED_DEPT_SAL
INNER JOIN DEPARTMENTS D
ON ORDERED_DEPT_SAL.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE ROWNUM = 1
;
-- 정렬된 데이터에서 1개만 조회.
-- 부서의 정보를 알기위해 JOIN 해야함.

-- EMPLOYEES 테이블에서 ROW 3개만 조회한다.
SELECT * FROM EMPLOYEES e WHERE EMPLOYEE_ID <=102;
SELECT * FROM EMPLOYEES e WHERE ROWNUM<=3;

-- 사원 수가 가장 많은 직무의 모든 정보 상위 3개를 조회한다.
SELECT J.* FROM (
	SELECT J.JOB_ID ,COUNT(E.EMPLOYEE_ID) AS EMPLOYEE_COUNT
	FROM JOBS j   
	LEFT JOIN EMPLOYEES e 
	ON J.JOB_ID = E.JOB_ID 
	GROUP BY J.JOB_ID 
	ORDER BY EMPLOYEE_COUNT DESC
) ORDERED_DEPT_EMP_CNT
INNER JOIN JOBS j  
ON ORDERED_DEPT_EMP_CNT.JOB_ID = J.JOB_ID 
WHERE ROWNUM =1
;

--재귀조인
--RootNode(최상위노드),LeafNode(자식노드)
-- 100번 사원이 모든 부하지권을 계층형(조직도) 구조로 조회한다.
SELECT EMPLOYEE_ID
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, MANAGER_ID
	, LEVEL --LEVEL 
	FROM EMPLOYEES e 
	START WITH EMPLOYEE_ID=100 -- ROOT NODE 지정
	CONNECT BY PRIOR EMPLOYEE_ID=MANAGER_ID -- ROOTNODE와 LEAFNODE 관계 설정
;

-- 108번 사원이 모든 부하지권을 계층형(조직도) 구조로 조회한다.
SELECT EMPLOYEE_ID
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, MANAGER_ID
	, LEVEL 
FROM EMPLOYEES e 
START WITH EMPLOYEE_ID = 108
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
;

-- 113번 사원의 상사를 계층형(조직도) 구조로 조회한다.
SELECT EMPLOYEE_ID
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, MANAGER_ID
	, LEVEL 
FROM EMPLOYEES e 
START WITH EMPLOYEE_ID = 113
CONNECT BY PRIOR  MANAGER_ID = EMPLOYEE_ID 
ORDER BY LEVEL DESC 
;

-- 매니저 아이디가 NULL인 사원의 모든 부하직원을 조회한다.
SELECT EMPLOYEE_ID
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, MANAGER_ID
	, LEVEL 
FROM EMPLOYEES e 
START WITH EMPLOYEE_ID = (SELECT EMPLOYEE_ID FROM EMPLOYEES e WHERE MANAGER_ID IS NULL)
--START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR  EMPLOYEE_ID = MANAGER_ID
;

-- 113번 사원의 모든 부하직원을 조회한다.
SELECT EMPLOYEE_ID
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, MANAGER_ID
	, LEVEL 
FROM EMPLOYEES e 
START WITH EMPLOYEE_ID = 113
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
;
-- 60번 부서장의 모든 부하직원을 조회한다.
SELECT EMPLOYEE_ID
	, FIRST_NAME || ' ' || LAST_NAME AS NAME
	, MANAGER_ID
	, LEVEL
 FROM EMPLOYEES e 
START WITH EMPLOYEE_ID = (SELECT MANAGER_ID  
							FROM DEPARTMENTS d 
							WHERE d.DEPARTMENT_ID = 60)
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
;

SELECT E.EMPLOYEE_ID
	, E.FIRST_NAME || ' ' || E.LAST_NAME AS NAME
	, E.MANAGER_ID
	, LEVEL
 FROM EMPLOYEES e
 INNER JOIN DEPARTMENTS d
 ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
START WITH E.EMPLOYEE_ID = D.MANAGER_ID AND D.DEPARTMENT_ID =60 -- WHERE 절이 START WITH CONNECT BY PRIOR 문보다 늦게 실행되므로 START WITH 조건에 추가해줘야한다.
CONNECT BY PRIOR E.EMPLOYEE_ID = E.MANAGER_ID
;

-- 60번 부서 부서장의 상사를 역순으로 조회한다.
SELECT LEVEL,E.* FROM EMPLOYEES e 
START WITH E.EMPLOYEE_ID = (SELECT MANAGER_ID FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID=60)
CONNECT BY PRIOR  E.MANAGER_ID = E.EMPLOYEE_ID
ORDER BY LEVEL DESC
;

-- 부하직원이 없는 사원을 모두 조회한다. (START WITH CONNECT BY PRIOR X)
SELECT E.*  FROM EMPLOYEES e 
LEFT JOIN EMPLOYEES e2 
ON E2.MANAGER_ID = E.EMPLOYEE_ID 
WHERE E2.EMPLOYEE_ID IS NULL
;

SELECT E.*  FROM EMPLOYEES e 
WHERE E.EMPLOYEE_ID NOT IN (SELECT MANAGER_ID FROM EMPLOYEES e2 WHERE MANAGER_ID IS NOT NULL)
;

SELECT E.*  FROM EMPLOYEES e 
WHERE E.EMPLOYEE_ID NOT IN (SELECT MANAGER_ID FROM EMPLOYEES e2) -- IN() 안에 NULL이 있을 경우 ORACLE 옵티마이저 변환 과정에서 문제가 생기므로 따로 조건을 걸어줘야 한다.
;

-- 부하직원이 없는 사원의 상사를 모두 조회한다.
SELECT LEVEL , E.* FROM EMPLOYEES e 
	START WITH E.EMPLOYEE_ID IN (SELECT E.EMPLOYEE_ID  FROM EMPLOYEES e 
								LEFT JOIN EMPLOYEES e2 
								ON E2.MANAGER_ID = E.EMPLOYEE_ID 
								WHERE E2.EMPLOYEE_ID IS NULL)
	CONNECT BY PRIOR  E.MANAGER_ID = E.EMPLOYEE_ID
;
------------------------------------------------ INSERT 시작 ------------------------------------------------
-- HR 회사의신규인력이 입사하였다. 
-- 이름은 민창
-- 성은 장	
-- 이메일에느 MCJANG
-- 연락처 010-1111-2222
-- 입사일 현재날짜(오늘)
-- 직무아이디 IT_PROG
-- 연봉 100000
-- 인세티브 NULL
-- 상사의 사원번호 100
-- 부서 번호 60	
SELECT E.* FROM EMPLOYEES e ORDER BY EMPLOYEE_ID DESC;

INSERT INTO HR.EMPLOYEES(
EMPLOYEE_ID
, FIRST_NAME
, LAST_NAME
, EMAIL
, PHONE_NUMBER
, HIRE_DATE
, JOB_ID
, SALARY
, COMMISSION_PCT
, MANAGER_ID
, DEPARTMENT_ID
)
VALUES(
208--EMPLOYEE_ID     
, '민창'--, FIRST_NAME    
, '장'--, LAST_NAME     
, 'MCJANG1'--, EMAIL         
, '010-1111-2222'--, PHONE_NUMBER  
, SYSDATE--, HIRE_DATE     
, 'IT_PROG'--, JOB_ID        
, 100000--, SALARY        
, NULL--, COMMISSION_PCT
, 100--, MANAGER_ID    
, 60--, DEPARTMENT_ID 
)
;

-- ORACLE QUERY OPTIMIZER 가 값을 타입에 맞춰 보정을 해준다. 하지만 MSSQL 하듯이 타입 맞춰서 넣자..
-- ORACLE 은 영어,숫자,공백은 1BYTE 그 외는 3BYTE

-- HR 회사에 신규 사업 부서가 생겼다.
-- 부서 번호 300
-- 부서명 : R&D
-- 부서장 사원 번호 : NULL
-- 지역 번호 : 1700
INSERT INTO DEPARTMENTS(
DEPARTMENT_ID
, DEPARTMENT_NAME
, MANAGER_ID
, LOCATION_ID
)
VALUES(
301--DEPARTMENT_ID
,'R&D'--, DEPARTMENT_NAME
,NULL--, MANAGER_ID
,1700--, LOCATION_ID
)
;

-- INSERT, UPDATE, DELETE
-- 테이블 데이터의 영향을 주는 QUERY
-- 실수로 적용한 쿼리의 실행결과를 테이블로 바로 적용되지 않도록
-- 방어해주는 최소한의 방어기재.
-- MANUAL TRANSACTION
-- TRANSACTION - COMMIT, ROLLBACK
-- COMMIT: INSERT, UPDATE, DELETE 쿼리의 결과를 테이블에 적용
-- ROLLBACK : INSERT, UPDATE, DELETE 쿼리의 결과를 취소
-- MANUAL TRANSACTION이 적용된 상태에서
-- INSERT, UPDATE, DELETE를 수행하면 COMMIT을 하기 전까지는 테이블에 적용되지 않는다.
-- AUTO TRANSACTION 
-- INSERT, UPDATE, DELETE를 수행하면 즉시 테이블에 적용.

-- 103번 사원의 연봉을 10만으로 변경 원래는 9000
UPDATE EMPLOYEES 
SET SALARY = 100000
, COMMISSION_PCT = 0.9
WHERE EMPLOYEES.EMPLOYEE_ID =103
;

SELECT * FROM EMPLOYEES e WHERE e.EMPLOYEE_ID =103
;

DELETE 
FROM EMPLOYEES e 
WHERE EMPLOYEE_ID = 207
;

DELETE 
FROM DEPARTMENTS d 
WHERE DEPARTMENT_ID = 300
;

SELECT * FROM EMPLOYEES e
;

SELECT * FROM DEPARTMENTS d 
;

COMMIT;












